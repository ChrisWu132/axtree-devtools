---
alwaysApply: true
---
# AXtreeTool Implementation Roadmap

> 本路线图面向“第一次落地”团队成员，假设已读完 `01_Product.mdc` 与 `02_Structure.mdc`。
> 所有命令均以 pnpm 为前提，根目录已 `pnpm install`。

---
## 阶段 0 ─ 基础仓库初始化

| Step | 目标 | 操作 | 产物 |
|------|------|------|------|
| 0-1 | 初始化 monorepo | `pnpm init -y && pnpm add -D typescript ts-node`<br/>创建 `pnpm-workspace.yaml` | 根层 package.json / tsconfig.base.json |
| 0-2 | ESLint & Prettier | `pnpm add -D eslint @typescript-eslint/parser prettier lint-staged husky`<br/>`npx eslint --init` | `.eslintrc.cjs` `.prettierrc` `lint-staged.config.js`|
| 0-3 | Vitest | `pnpm add -D vitest @vitest/coverage-c8` | `vitest.config.ts` |
| 0-4 | GitHub CI | 新建 `.github/workflows/ci.yml` （安装 → lint → test） | ci.yml |

✅ CI 绿灯之后进入阶段 1。

### 0.x 关键配置示例

#### 包内 package.json 样板 (以 `@ax/cli` 为例)
```jsonc
{
  "name": "@ax/cli",
  "version": "0.1.0",
  "description": "Headless AXTree CLI",
  "bin": {
    "axtree": "dist/cli.js"
  },
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc -p tsconfig.pkg.json",
    "test": "vitest",
    "lint": "eslint src --ext .ts",
    "prepublishOnly": "npm run build && npm test"
  },
  "dependencies": {
    "commander": "^11.0.0"
  },
  "devDependencies": {
    "typescript": "^5.4.0",
    "vitest": "^0.34.0",
    "@types/node": "latest"
  }
}
```

#### tsconfig.pkg.json（各包继承）
```jsonc
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declaration": true,
    "declarationDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src"]
}
```

> 每个包的 `build` 脚本指向 `tsc -p tsconfig.pkg.json`，即可同时输出 JS 和 `.d.ts`。

`pnpm-workspace.yaml`
```yaml
packages:
  - "packages/*"
```

`tsconfig.base.json`
```jsonc
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Node",
    "strict": true,
    "esModuleInterop": true,
    "types": ["node"],
    "rootDir": ".",
    "composite": true
  }
}
```

`.eslintrc.cjs`
```js
module.exports = {
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint"],
};
```


---
## 阶段 1 ─ Core & Bridge MVP（命令：connect + 全量树）

### 1.1 创建 `@ax/core`

```
packages/core/src/
├─ types.ts        // export type AXNodeFlat, AXNodeTree, Diff
├─ parser.ts       // export function buildTree(list: AXNodeFlat[]): AXNodeTree
└─ index.ts        // re-export
```

测试：`packages/core/tests/parser.spec.ts`
```
import { expect, test } from 'vitest';
import { buildTree } from '../src/parser';

// mock 3-node flat list
```

### 1.2 创建 `@ax/bridge`

```
packages/bridge/src/
├─ CdpClient.ts         // class CdpClient { enableDomains(); getFullAXTree(); onNodesUpdated(cb) }
├─ WebSocketServer.ts   // wraps ws, topic-based broadcast
├─ index.ts             // CLI 调用入口：new Bridge(port, host)
└─ mocks/ (for vitest)  // stub CDP responses
```

#### Bridge 消息格式（Browser → UI）
```ts
// packages/bridge/src/types.ts
type SnapshotMsg = {
  type: 'snapshot';
  payload: AXNodeTree;
};

type UserEvtMsg = {
  type: 'userEvent';
  payload: CDPInputEvent | DomEvent;
};

type DeltaMsg = {
  type: 'delta';
  payload: JsonDiffPatchDelta;
};
```


测试：`CdpClient.spec.ts` 使用 vitest + msw nodeMock。

### 1.3 CLI connect

```
packages/cli/src/commands/connect.ts
```
功能：
1. 校验参数 → ping `http://host:port/json/version`。
2. `import("@ax/bridge")` 动态启动 Bridge（child_process.fork）。
3. 启动 UI dev 服务器（`pnpm --filter @ax/ui dev`）。

单元测试：`connect.spec.ts` 使用 `vi.mock('child_process')`。

> 到此可在终端执行：
> ```bash
> pnpm cli connect --port 9222
> ```
> 用浏览器打开 localhost:5173，虽然 UI 为空，但 Network 能看到 `/ax-tree` payload。

---
## 阶段 2 ─ UI Minimum Feature

### 2.1 Vite + React 脚手架（已由 filter dev 启动）
目录见 `FILE_STRUCTURE.mdc`。

### 2.2 WebSocket hook
`useAxTreeSocket.ts`：保持与 Bridge 的 WS，收到 `type:'snapshot'` → setTree。

### 2.3 TreeView 组件
采用 **react-arborist**：
```tsx
<Tree data={treeData} rowHeight={22} onSelect={setActive} />
```

测试：`TreeView.spec.tsx` 使用 vitest + testing-library React，mock 10000 节点渲染，不应卡死。

### 2.4 高亮交互
点击节点 → WS `highlight:{backendNodeId}` → Bridge → CDP Runtime.evaluate outline。

---
## 阶段 3 ─ 增量更新 & 体验 (已完成)

1. Bridge 订阅 `Accessibility.nodesUpdated` → payload `type:'delta'`。 
2. core/diff.ts 使用 **jsondiffpatch** 计算 delta（或直接转发节点列表）。
3. UI `state.ts` 使用 immer 以 delta 更新。
4. 节点详情面板，搜索框等。

E2E：Playwright 脚本导航 github.com。断言 UI 节点文本存在。

---
## 阶段 4 ─ 增量时间线调试器 (record)

这是项目的下一个核心里程碑，我们将实现一个高效的、基于 **增量** 的时间线录制器。

**核心理念：** 不再是每次交互都保存一个完整的树快照，而是只在录制开始时保存一个 **初始快照 (Initial Snapshot)**，之后每次 AX Tree 发生变化时，只记录 **树的差异 (Delta)**。这种方法将大大减小产出文件的大小，并提升录制和回放的性能。

### 实现规划

| 模块 | 核心任务 | 技术细节 |
|---|---|---|
| **@ax/cli** | `record` 命令 | 1. `axtree record --port 9222 --output timeline.json` **附着**到正在运行的浏览器。<br/>2. **在主进程中** 实例化 Bridge，并配置为录制模式。<br/>3. 监听 Bridge 发出的 `recording-stopped` 事件，然后将收集到的数据写入指定的输出文件。 |
| **@ax/bridge** | **增量采集引擎** | 1. 启动时，获取并存储完整的 **初始无障碍树**。<br/>2. 监听 CDP 的 `Accessibility.nodesUpdated` 事件。<br/>3. 当事件触发时，**计算新树与前一状态树的差异 (delta)**，并将这个 `delta` 和触发它的用户输入事件（如 click, keydown）一同存储。<br/>4. `stopRecording()` 时，将包含初始快照和一系列 delta 的完整 `Recording` 对象返回给 CLI。|
| **@ax/core** | **数据结构** | 在 `types.ts` 中修改 `Recording` 结构，使其包含一个 `initialSnapshot` 和一个 `timeline` 数组，数组中每个条目包含 `event` 和 `delta`。 |
| **@ax/ui** | **增量播放器** | 1. `TimelinePlayer` 加载 `.axtree-timeline.json` 文件。<br/>2. UI 内部维护一个 **当前树状态**。初始时，显示 `initialSnapshot`。<br/>3. 当用户在时间线上移动时，**UI 动态地应用或撤销 (patch/unpatch) delta** 来从初始快照计算出任何时间点的树状态。 |

### 数据结构示例 (`.axtree-timeline.json`)
```ts
// packages/core/src/types.ts

// Delta (差异) 的具体格式由 jsondiffpatch 定义
type AXNodeTreeDelta = object; 

interface TimelineEntry {
  timestamp: number;
  // 触发变化的事件
  event?: { type: string; details: any; };
  // 从前一状态到当前状态的树的差异
  delta: AXNodeTreeDelta; 
}

interface Recording {
  metadata: { /* ... */ };
  // 录制开始时的完整树
  initialSnapshot: AXNodeTree;
  // 后续所有变化的时间线
  timeline: TimelineEntry[];
}
```

---
## 阶段 5 ─ E2E 测试 & 硬化

1.  **E2E 测试:**
    *   创建 `tests/e2e/record.spec.ts`。
    *   测试场景：启动 `record` 命令录制一个包含特定交互（如点击按钮）的简单页面。
    *   断言：验证生成的 `.axtree-timeline.json` 文件中是否包含正确的 `initialSnapshot` 和预期的 `delta`。
2.  **硬化:**
    *   确保 `patch` 和 `unpatch` 在各种边界情况下都能正确工作。
    *   优化 `delta` 计算的性能。
3.  **发布:**
    *   将 `@ax/cli` 打包为 `bin` 并发布到 npm。

---
## 未来功能

| 命令 | 核心定位 | 实现思路 |
|---|---|---|
| `snapshot` | **离线快照查看器** | 启动 headless Chrome 捕获单点的 AX Tree 并保存为 `.axtree` 文件。|
| `diff` | **无障碍回归探测器** | 对比两个 `.axtree` 文件并生成 HTML 差异报告。|

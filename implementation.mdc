---
alwaysApply: true
---
# AXtreeTool Implementation Roadmap

> 本路线图面向“第一次落地”团队成员，假设已读完 `01_Product.mdc` 与 `02_Structure.mdc`。
> 所有命令均以 pnpm 为前提，根目录已 `pnpm install`。

---
## 阶段 0 ─ 基础仓库初始化

| Step | 目标 | 操作 | 产物 |
|------|------|------|------|
| 0-1 | 初始化 monorepo | `pnpm init -y && pnpm add -D typescript ts-node`<br/>创建 `pnpm-workspace.yaml` | 根层 package.json / tsconfig.base.json |
| 0-2 | ESLint & Prettier | `pnpm add -D eslint @typescript-eslint/parser prettier lint-staged husky`<br/>`npx eslint --init` | `.eslintrc.cjs` `.prettierrc` `lint-staged.config.js`|
| 0-3 | Vitest | `pnpm add -D vitest @vitest/coverage-c8` | `vitest.config.ts` |
| 0-4 | GitHub CI | 新建 `.github/workflows/ci.yml` （安装 → lint → test） | ci.yml |

✅ CI 绿灯之后进入阶段 1。

### 0.x 关键配置示例

#### 包内 package.json 样板 (以 `@ax/cli` 为例)
```jsonc
{
  "name": "@ax/cli",
  "version": "0.1.0",
  "description": "Headless AXTree CLI",
  "bin": {
    "axtree": "dist/cli.js"
  },
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc -p tsconfig.pkg.json",
    "test": "vitest",
    "lint": "eslint src --ext .ts",
    "prepublishOnly": "npm run build && npm test"
  },
  "dependencies": {
    "commander": "^11.0.0"
  },
  "devDependencies": {
    "typescript": "^5.4.0",
    "vitest": "^0.34.0",
    "@types/node": "latest"
  }
}
```

#### tsconfig.pkg.json（各包继承）
```jsonc
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declaration": true,
    "declarationDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src"]
}
```

> 每个包的 `build` 脚本指向 `tsc -p tsconfig.pkg.json`，即可同时输出 JS 和 `.d.ts`。

`pnpm-workspace.yaml`
```yaml
packages:
  - "packages/*"
```

`tsconfig.base.json`
```jsonc
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Node",
    "strict": true,
    "esModuleInterop": true,
    "types": ["node"],
    "rootDir": ".",
    "composite": true
  }
}
```

`.eslintrc.cjs`
```js
module.exports = {
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint"],
};
```


---
## 阶段 1 ─ Core & Bridge MVP（命令：connect + 全量树）

### 1.1 创建 `@ax/core`

```
packages/core/src/
├─ types.ts        // export type AXNodeFlat, AXNodeTree, Diff
├─ parser.ts       // export function buildTree(list: AXNodeFlat[]): AXNodeTree
└─ index.ts        // re-export
```

测试：`packages/core/tests/parser.spec.ts`
```
import { expect, test } from 'vitest';
import { buildTree } from '../src/parser';

// mock 3-node flat list
```

### 1.2 创建 `@ax/bridge`

```
packages/bridge/src/
├─ CdpClient.ts         // class CdpClient { enableDomains(); getFullAXTree(); onNodesUpdated(cb) }
├─ WebSocketServer.ts   // wraps ws, topic-based broadcast
├─ index.ts             // CLI 调用入口：new Bridge(port, host)
└─ mocks/ (for vitest)  // stub CDP responses
```

#### Bridge 消息格式（Browser → UI）
```ts
// packages/bridge/src/types.ts
type SnapshotMsg = {
  type: 'snapshot';
  payload: AXNodeTree;
};

type UserEvtMsg = {
  type: 'userEvent';
  payload: CDPInputEvent | DomEvent;
};

type DeltaMsg = {
  type: 'delta';
  payload: JsonDiffPatchDelta;
};
```


测试：`CdpClient.spec.ts` 使用 vitest + msw nodeMock。

### 1.3 CLI connect

```
packages/cli/src/commands/connect.ts
```
功能：
1. 校验参数 → ping `http://host:port/json/version`。
2. `import("@ax/bridge")` 动态启动 Bridge（child_process.fork）。
3. 启动 UI dev 服务器（`pnpm --filter @ax/ui dev`）。

单元测试：`connect.spec.ts` 使用 `vi.mock('child_process')`。

> 到此可在终端执行：
> ```bash
> pnpm cli connect --port 9222
> ```
> 用浏览器打开 localhost:5173，虽然 UI 为空，但 Network 能看到 `/ax-tree` payload。

---
## 阶段 2 ─ UI Minimum Feature

### 2.1 Vite + React 脚手架（已由 filter dev 启动）
目录见 `FILE_STRUCTURE.mdc`。

### 2.2 WebSocket hook
`useAxTreeSocket.ts`：保持与 Bridge 的 WS，收到 `type:'snapshot'` → setTree。

### 2.3 TreeView 组件
采用 **react-arborist**：
```tsx
<Tree data={treeData} rowHeight={22} onSelect={setActive} />
```

测试：`TreeView.spec.tsx` 使用 vitest + testing-library React，mock 10000 节点渲染，不应卡死。

### 2.4 高亮交互
点击节点 → WS `highlight:{backendNodeId}` → Bridge → CDP Runtime.evaluate outline。

---
## 阶段 3 ─ 增量更新 & 体验

1. Bridge 订阅 `Accessibility.nodesUpdated` → payload `type:'delta'`。 
2. core/diff.ts 使用 **jsondiffpatch** 计算 delta（或直接转发节点列表）。
3. UI `state.ts` 使用 immer 以 delta 更新。
4. 节点详情面板，搜索框等。

E2E：Playwright 脚本导航 github.com。断言 UI 节点文本存在。

---
## 阶段 4 ─ CLI snapshot / record / replay

| 命令 | 核心流程 | 关键存储 |
|------|----------|----------|
| snapshot | `launch.ts` 启动 Chrome --headless<br/>导航 URL → getFullAXTree → JSON | `snapshot-yyyymmdd.json`|
| record   | **同步捕获交互事件+AX 树**：监听 CDP `Input.dispatch*` & 注入 `Page.addScriptToEvaluateOnNewDocument` 采集 `click / input / focus`，同时每 ρms 拉树，落盘 `{ ts, event?, snapshot? }[]` | `record-*.json`|
| replay   | 读取 record.json → 重放事件 → 对比快照差异 → 生成 HTML 报告 | `report.html`|

测试：利用 Playwright 的 browserType.launchServer 作为假浏览器。

---
## 阶段 5 ─ 硬化 & 发布

1. bun / vite build ui → `dist/` + serve via express (bridge 内部)。
2. `@ax/cli` 打包为 `bin`，使用 `pkg` 或 `nexe` 生成单文件可执行（可选）。
3. 语义化发布脚本：`scripts/release.ts` 调用 `changesets` + GitHub Release。

---
## 测试矩阵速览

| 层 | 工具 | 触发 |
|----|------|------|
| 单元 | vitest | push / PR |
| UI 组件 | vitest + react-testing-library | push / PR |
| Bridge   | vitest (mock CDP) | push / PR |
| 集成 | Playwright headless | nightly |
| a11y | axe-core on UI | PR (UI) |

---
## 仍可用库直接解决的细节

1. **键盘导航 & ARIA**：React-Arborist 已内置多键盘交互；若需进一步 a11y，可引入 `@react-aria/focus`。
2. **录制辅助**：`chrome-devtools-frontend` 的 `Recorder` 协议已开放，可作为 record 命令的底层实现，减少自研。 
3. **CDP Type 自动生成**：使用 `@puppeteer/replay` 里的 protocol-types 以保证 TS 精度。 
4. **报告模板**：采用 `vite-plugin-static-copy` + `handlebars` 一键生成 HTML 报告，而非手写 DOM。

总体来看，核心难点（AX 解析 + diff + 虚拟树 + CDP 桥接）均已有社区库辅助，现阶段不需要再额外引入大型依赖。